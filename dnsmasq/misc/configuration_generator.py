##
#     Project: Django dnsmasq
# Description: A Django application to create dnsmasq configuration
#      Author: Fabio Castelli (Muflone) <muflone@muflone.com>
#   Copyright: 2021 Fabio Castelli
#     License: GPL-3+
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
##

from dnsmasq.constants import MAC_ADDRESS_ZEROS, MAC_ADDRESS_ANY
from dnsmasq.models import (DhcpHost,
                            DhcpOption,
                            DhcpOptionType,
                            DhcpRange,
                            DhcpTag,
                            Domain,
                            Interface,
                            ListenAddress,
                            Option)

from project import PRODUCT_NAME, VERSION


class ConfigurationGenerator(object):
    def __init__(self, include_descriptions: bool):
        self.include_descriptions = include_descriptions

    @staticmethod
    def add_header(title: str) -> str:
        """
        Add section header to the configuration file

        :param title: section title
        :return: header description
        """
        separator = '-' * 77
        return f'\n# {separator}\n# {title}\n# {separator}'

    def add_description(self, name: str, description: str) -> str:
        """
        Add name and description to the configuration file

        :param name: option name
        :param description: option description
        :return: resulting description
        """
        results = None
        if self.include_descriptions and (description or name):
            if name and description:
                results = f'# {name}: {description}'
            elif name:
                results = f'# {name}'
            else:
                results = f'# {description}'
        return results

    @staticmethod
    def get_option_value(option: DhcpOption) -> str:
        """
        Get value for a DhcpOption object

        :param option: DHCP option to check
        :return: resulting value
        """
        if option.option.type in (DhcpOptionType.IPV4_X1,
                                  DhcpOptionType.IPV4_X2,
                                  DhcpOptionType.IPV4_MANY):
            options = option.dhcpoptionipv4_set.order_by('order')
            if option.option.type == DhcpOptionType.IPV4_X1:
                # Use only the first value
                options = options[:1]
            elif option.option.type == DhcpOptionType.IPV4_X2:
                # Use only the first two values
                options = options[:2]
            # Format values
            results = ','.join(option.address
                               for option
                               in options)
        elif option.option.type == DhcpOptionType.CHARACTER:
            results = option.character_value
        else:
            results = str(option.numeric_value)
        return results

    def process(self):
        """
        Create the configuration file
        """
        results = []
        results.append(f'# Configuration file for dnsmasq created '
                       f'automatically by '
                       f'{PRODUCT_NAME} v.{VERSION}')
        results.append('# Please do not edit this file directly')
        # Active Interfaces
        if queryset := Interface.objects_enabled.filter(excluded=False):
            results.append(self.add_header('Active interfaces'))
            for item in queryset.order_by('order'):
                results.append(self.add_description(item.name,
                                                    item.description))
                results.append(f'interface={item.name}')
        # Excluded Interfaces
        if queryset := Interface.objects_enabled.filter(excluded=True):
            results.append(self.add_header('Excluded Interfaces'))
            for item in queryset.order_by('order'):
                results.append(self.add_description(item.name,
                                                    item.description))
                results.append(f'except-interface={item.name}')
        # No DHCP Interfaces
        if queryset := Interface.objects_enabled.filter(disable_dhcp=True):
            results.append(self.add_header('No DHCP Interfaces'))
            for item in queryset.order_by('order'):
                results.append(self.add_description(item.name,
                                                    item.description))
                results.append(f'no-dhcp-interface={item.name}')
        # Listen addresses
        if queryset := ListenAddress.objects_enabled.all():
            results.append(self.add_header('Listening addresses'))
            for item in queryset.order_by('order'):
                results.append(self.add_description(item.address,
                                                    item.description))
                results.append(f'listen-address={item.address}')
        # Options
        if queryset := Option.objects_enabled.all():
            results.append(self.add_header('Options'))
            for item in queryset.order_by('order'):
                results.append(self.add_description(item.name,
                                                    item.description))
                if len(item.value):
                    # Option with value
                    results.append(f'{item.option}={item.value}')
                else:
                    # Option with no value
                    results.append(f'{item.option}')
        # Domains
        if queryset := Domain.objects_enabled.all():
            results.append(self.add_header('Domains'))
            for item in queryset.order_by('order'):
                results.append(self.add_description(item.name,
                                                    item.description))
                line = f'domain={item.name}'
                if item.subnet_ip:
                    line += f',{item.subnet_ip}/{item.subnet_cidr}'
                if item.starting_ip:
                    line += f',{item.starting_ip},{item.ending_ip}'
                results.append(line)
        # DHCP ranges
        if queryset := DhcpRange.objects_enabled.all():
            results.append(self.add_header('DHCP ranges'))
            for item in queryset.order_by('order'):
                results.append(self.add_description(item.name,
                                                    item.description))
                results.append(f'dhcp-range={item.starting_ip},'
                               f'{item.ending_ip},'
                               f'{item.lease_time}m')
        # DHCP default options
        if queryset := DhcpOption.objects_enabled.filter(
                tag__name=DhcpTag.DEFAULT_TAG,
                forced=False):
            results.append(self.add_header('DHCP default options'))
            for item in queryset:
                results.append(self.add_description(item.option.name,
                                                    item.option.description))
                value = self.get_option_value(option=item)
                results.append(f'dhcp-option={item.option.option},{value}')
        # DHCP forced default options
        if queryset := DhcpOption.objects_enabled.filter(
                tag__name=DhcpTag.DEFAULT_TAG,
                forced=True):
            results.append(self.add_header('DHCP forced default options'))
            for item in queryset:
                results.append(self.add_description(item.option.name,
                                                    item.option.description))
                value = self.get_option_value(option=item)
                results.append(f'dhcp-option-force={item.option.option},'
                               f'{value}')
        # DHCP options for tags
        if queryset := DhcpOption.objects_enabled.filter(
                forced=False).exclude(tag__name=DhcpTag.DEFAULT_TAG):
            results.append(self.add_header('DHCP options for tags'))
            last_tag_id = None
            for item in queryset.order_by('tag', 'option'):
                # Skip duplicated tags description
                if last_tag_id != item.tag_id:
                    results.append(self.add_description(item.tag.name,
                                                        item.tag.description))
                    last_tag_id = item.tag_id
                results.append(self.add_description(item.option.name,
                                                    item.option.description))
                value = self.get_option_value(option=item)
                results.append(f'dhcp-option=tag:{item.tag.name},'
                               f'{item.option.option},{value}')
        # DHCP forced options for tags
        if queryset := DhcpOption.objects_enabled.filter(
                forced=True).exclude(tag__name=DhcpTag.DEFAULT_TAG):
            results.append(self.add_header('DHCP forced options for tags'))
            last_tag_id = None
            for item in queryset.order_by('tag', 'option'):
                # Skip duplicated tags description
                if last_tag_id != item.tag_id:
                    results.append(self.add_description(item.tag.name,
                                                        item.tag.description))
                    last_tag_id = item.tag_id
                results.append(self.add_description(item.option.name,
                                                    item.option.description))
                value = self.get_option_value(option=item)
                results.append(f'dhcp-option-force=tag:{item.tag.name},'
                               f'{item.option.option},{value}')
        # Ignored DHCP hosts
        if queryset := DhcpHost.objects_enabled.filter(ignored=True):
            results.append(self.add_header('Ignored hosts'))
            for item in queryset:
                results.append(self.add_description(item.name,
                                                    item.description))
                mac_address = (item.mac_address
                               if item.mac_address != MAC_ADDRESS_ZEROS
                               else MAC_ADDRESS_ANY)
                results.append(f'dhcp-host={mac_address},ignore')
        # Allowed DHCP hosts
        if queryset := DhcpHost.objects_enabled.filter(ignored=False):
            results.append(self.add_header('Allowed hosts'))
            for item in queryset:
                results.append(self.add_description(item.name,
                                                    item.description))
                mac_address = (item.mac_address
                               if item.mac_address != MAC_ADDRESS_ZEROS
                               else MAC_ADDRESS_ANY)
                # Add DHCP Host
                line = f'dhcp-host={mac_address}'
                if item.tag and item.tag.name != DhcpTag.DEFAULT_TAG:
                    # Add tag
                    line += f',set:{item.tag}'
                if item.address:
                    # Add IP address
                    line += f',{item.address}'
                if item.hostname:
                    # Add hostname
                    line += f',{item.hostname}'
                if item.lease_time > 0:
                    # Add lease time
                    line += f',{item.lease_time}m'
                elif item.lease_time < 0:
                    # Add infinite lease time
                    line += ',infinite'
                results.append(line)
        return '\n'.join(filter(lambda line: line is not None, results))
